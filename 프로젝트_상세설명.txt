# 오목 게임 프로젝트 - 전체 구조 및 알고리즘 상세 설명

## 목차
1. [프로젝트 개요](#프로젝트-개요)
2. [시스템 아키텍처](#시스템-아키텍처)
3. [데이터베이스 설계](#데이터베이스-설계)
4. [핵심 알고리즘](#핵심-알고리즘)
5. [백엔드 구조](#백엔드-구조)
6. [프론트엔드 구조](#프론트엔드-구조)
7. [API 명세](#api-명세)
8. [실시간 통신](#실시간-통신)

---

## 프로젝트 개요

### 기술 스택
- **Backend**: Node.js 18+, Express 4.18
- **Database**: MySQL 5.7+
- **Real-time**: Socket.IO 4.6
- **Frontend**: Vanilla JavaScript, HTML5 Canvas
- **Security**: bcrypt (비밀번호 암호화), express-session

### 주요 기능
1. **AI 대전**: Minimax 알고리즘 기반 3단계 난이도 (초급/중급/고급)
2. **1:1 실시간 대전**: Socket.IO 기반 매칭 시스템
3. **게임 저장/불러오기**: MySQL에 게임 상태 저장
4. **사용자 인증**: 세션 기반 로그인 시스템
5. **통계 및 전적**: 승/패/무 기록, 리더보드

---

## 시스템 아키텍처

### 전체 구조도

```
┌─────────────────────────────────────────────────────────────┐
│                        Client (Browser)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   HTML/CSS   │  │  Canvas API  │  │  Socket.IO   │      │
│  │              │  │ (Game Board) │  │   Client     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │              │
│         └──────────────────┴──────────────────┘              │
│                            │                                 │
└────────────────────────────┼─────────────────────────────────┘
                             │ HTTP/WebSocket
                             │
┌────────────────────────────┼─────────────────────────────────┐
│                   Node.js Express Server                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │    Routes    │  │  Game Logic  │  │  Socket.IO   │      │
│  │ (auth, game, │  │  (gameLogic  │  │   Server     │      │
│  │   stats)     │  │   ai.js)     │  │              │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │              │
│         └──────────────────┴──────────────────┘              │
│                            │                                 │
└────────────────────────────┼─────────────────────────────────┘
                             │ MySQL Protocol
                             │
┌────────────────────────────┼─────────────────────────────────┐
│                       MySQL Database                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │  users   │  │saved_    │  │  game_   │  │user_     │    │
│  │          │  │games     │  │ records  │  │statistics│    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 데이터 흐름

#### 1. AI 대전 플로우
```
사용자 착수 → Canvas 클릭 이벤트
    ↓
게임 로직 검증 (isValidMove)
    ↓
보드 상태 업데이트 + 승리 확인
    ↓
AI 차례 → POST /api/game/ai-move
    ↓
서버에서 Minimax 알고리즘 실행
    ↓
최적 수 반환 → 화면에 렌더링
    ↓
승리 확인 → 게임 결과 저장
```

#### 2. 1:1 대전 플로우
```
사용자1 "1:1 대전" 클릭
    ↓
Socket emit('find-match')
    ↓
대기열 추가 or 매칭
    ↓
사용자2 "1:1 대전" 클릭
    ↓
매칭 완료 → emit('match-found')
    ↓
게임 시작 (하나의 게임 룸 생성)
    ↓
착수 시 emit('make-move')
    ↓
상대방에게 broadcast
    ↓
승리 시 결과 기록
```

---

## 데이터베이스 설계

### ERD (Entity Relationship Diagram)

```
┌─────────────┐
│    users    │
│─────────────│
│ id (PK)     │───┐
│ username    │   │
│ password    │   │
│ email       │   │
│ created_at  │   │
└─────────────┘   │
                  │ 1:N
                  │
        ┌─────────┴─────────┬─────────────────┬─────────────────┐
        │                   │                 │                 │
        │                   │                 │                 │
┌───────▼──────┐    ┌───────▼──────┐  ┌──────▼─────┐  ┌───────▼──────┐
│ saved_games  │    │game_records  │  │user_       │  │game_records  │
│──────────────│    │──────────────│  │statistics  │  │(as player2)  │
│ id (PK)      │    │ id (PK)      │  │────────────│  └──────────────┘
│ user_id (FK) │    │player1_id(FK)│  │user_id(PK) │
│ game_name    │    │player2_id(FK)│  │total_games │
│ board_state  │    │ game_mode    │  │ wins       │
│ current_     │    │ ai_difficulty│  │ losses     │
│   player     │    │ winner_id(FK)│  │ draws      │
│ game_mode    │    │ result       │  │ai_*_wins   │
│ ai_difficulty│    │ total_moves  │  │pvp_wins    │
│ move_history │    │ played_at    │  │average_    │
│ created_at   │    └──────────────┘  │  moves     │
│ updated_at   │                      └────────────┘
└──────────────┘
```

### 테이블 상세 설명

#### 1. users (사용자 테이블)
```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,      -- 사용자명 (고유)
    password VARCHAR(255) NOT NULL,            -- bcrypt 해시 비밀번호
    email VARCHAR(100) UNIQUE,                 -- 이메일 (선택)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_username (username)
);
```

**목적**: 사용자 계정 정보 저장
**보안**: bcrypt로 비밀번호 해싱 (salt rounds: 10)

#### 2. saved_games (저장된 게임)
```sql
CREATE TABLE saved_games (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    game_name VARCHAR(100) NOT NULL,           -- 사용자 정의 게임 이름
    board_state JSON NOT NULL,                 -- 15x15 배열 (JSON)
    current_player ENUM('black', 'white'),     -- 현재 차례
    game_mode ENUM('ai', 'pvp'),              -- 게임 모드
    ai_difficulty ENUM('easy','medium','hard'),-- AI 난이도
    move_history JSON,                         -- 착수 기록 배열
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

**board_state 형식**:
```json
[
  [null, null, "black", null, ...],  // 15개
  [null, "white", null, null, ...],
  ...  // 15줄
]
```

**move_history 형식**:
```json
[
  {"row": 7, "col": 7, "color": "black"},
  {"row": 7, "col": 8, "color": "white"},
  ...
]
```

#### 3. game_records (게임 전적)
```sql
CREATE TABLE game_records (
    id INT AUTO_INCREMENT PRIMARY KEY,
    player1_id INT NOT NULL,                   -- 주 플레이어
    player2_id INT,                            -- 상대 (PVP만)
    game_mode ENUM('ai', 'pvp'),
    ai_difficulty ENUM('easy','medium','hard'),
    winner_id INT,                             -- 승자 ID
    result ENUM('win', 'lose', 'draw'),       -- player1 기준
    total_moves INT,                           -- 총 착수 수
    game_duration INT,                         -- 게임 시간(초)
    played_at TIMESTAMP,
    FOREIGN KEY (player1_id) REFERENCES users(id),
    FOREIGN KEY (player2_id) REFERENCES users(id),
    FOREIGN KEY (winner_id) REFERENCES users(id)
);
```

**목적**: 완료된 게임 기록 및 통계 계산

#### 4. user_statistics (통계 캐시)
```sql
CREATE TABLE user_statistics (
    user_id INT PRIMARY KEY,
    total_games INT DEFAULT 0,
    wins INT DEFAULT 0,
    losses INT DEFAULT 0,
    draws INT DEFAULT 0,
    ai_easy_wins INT DEFAULT 0,
    ai_medium_wins INT DEFAULT 0,
    ai_hard_wins INT DEFAULT 0,
    pvp_wins INT DEFAULT 0,
    average_moves DECIMAL(10, 2),
    last_updated TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

**목적**: 빠른 통계 조회를 위한 집계 테이블 (게임 종료 시 업데이트)

---

## 핵심 알고리즘

### 1. Minimax 알고리즘 (AI)

#### 알고리즘 개요
Minimax는 게임 이론에서 사용되는 결정 알고리즘으로, 상대방이 최선의 수를 둔다고 가정하고 자신의 최악의 상황을 최대화하는 전략입니다.

#### 의사 코드
```
function minimax(board, depth, alpha, beta, isMaximizing, aiColor):
    if depth == 0:
        return evaluateBoard(board, aiColor)

    possibleMoves = getPossibleMoves(board)

    if isMaximizing:  // AI 차례
        maxScore = -∞
        for each move in possibleMoves:
            place stone at move
            if win:
                return INFINITY

            score = minimax(board, depth-1, alpha, beta, false, aiColor)
            remove stone

            maxScore = max(maxScore, score)
            alpha = max(alpha, score)

            if beta <= alpha:  // Alpha-Beta Pruning
                break

        return maxScore

    else:  // 상대 차례
        minScore = +∞
        for each move in possibleMoves:
            place stone at move
            if opponent wins:
                return -INFINITY

            score = minimax(board, depth-1, alpha, beta, true, aiColor)
            remove stone

            minScore = min(minScore, score)
            beta = min(beta, score)

            if beta <= alpha:  // Alpha-Beta Pruning
                break

        return minScore
```

#### Alpha-Beta Pruning 설명

Alpha-Beta Pruning은 탐색 공간을 줄이는 최적화 기법입니다.

```
예시:
        MAX
       /   \
     /       \
   MIN       MIN
   / \       / \
  3   5     2   ?

MAX는 왼쪽에서 3을 얻었습니다.
오른쪽 MIN 노드에서 2를 발견했으므로,
오른쪽의 ?는 탐색할 필요가 없습니다.
(MIN은 2 이하를 선택할 것이고, MAX는 이미 3을 가지고 있음)
```

**효과**: 탐색 노드 수가 O(b^d)에서 O(b^(d/2))로 감소

#### 실제 구현 (ai.js)

```javascript
function minimax(board, depth, alpha, beta, isMaximizing, aiColor) {
    const opponent = aiColor === 'black' ? 'white' : 'black';

    // 종료 조건: 깊이 0 도달
    if (depth === 0) {
        return { score: evaluateBoard(board, aiColor) };
    }

    const possibleMoves = getPossibleMoves(board, depth > 2 ? 10 : 15);

    if (isMaximizing) {
        let maxScore = -Infinity;
        let bestMove = null;

        for (const move of possibleMoves) {
            const { row, col } = move;

            // 착수
            board[row][col] = aiColor;

            // 즉시 승리 확인
            if (checkWin(board, row, col, aiColor)) {
                board[row][col] = null;
                return { score: 1000000, row, col };
            }

            // 재귀 호출
            const result = minimax(board, depth - 1, alpha, beta, false, aiColor);

            // 착수 취소
            board[row][col] = null;

            if (result.score > maxScore) {
                maxScore = result.score;
                bestMove = { row, col };
            }

            alpha = Math.max(alpha, result.score);
            if (beta <= alpha) {
                break; // Beta cutoff
            }
        }

        return { score: maxScore, ...bestMove };
    } else {
        // MIN 노드 (상대방 차례)
        // ... 유사한 로직
    }
}
```

#### 평가 함수 (Heuristic)

보드 상태를 점수화하는 함수:

```javascript
function evaluateBoard(board, color) {
    let score = 0;

    // 각 위치에 대해
    for (let row = 0; row < 15; row++) {
        for (let col = 0; col < 15; col++) {
            if (board[row][col] === color) {
                score += evaluatePosition(board, row, col, color);
            } else if (board[row][col] === opponent) {
                score -= evaluatePosition(board, row, col, opponent);
            }
        }
    }

    return score;
}

function evaluatePosition(board, row, col, color) {
    let score = 0;

    // 4방향 체크 (가로, 세로, 대각선 2개)
    for (direction in [horizontal, vertical, diagonal1, diagonal2]) {
        let consecutiveCount = countConsecutive(board, row, col, direction, color);
        let empty = countEmpty(board, row, col, direction);

        // 패턴별 점수
        if (consecutiveCount >= 4) score += 100000;  // 5목 (승리)
        else if (consecutiveCount == 3 && empty >= 1) score += 10000;  // 4목
        else if (consecutiveCount == 2 && empty >= 2) score += 1000;   // 3목
        else if (consecutiveCount == 1 && empty >= 3) score += 100;    // 2목
    }

    // 중앙 가산점
    centerDistance = abs(row - 7) + abs(col - 7);
    score += (14 - centerDistance) * 10;

    return score;
}
```

**점수 체계**:
- 5목 완성: 100,000점 (즉시 승리)
- 4목 (한 수로 이길 수 있음): 10,000점
- 3목 (두 수로 이길 가능성): 1,000점
- 2목: 100점
- 중앙 위치 보너스: 최대 140점

#### 난이도별 설정

```javascript
const depthMap = {
    'easy': 2,      // 2수 앞을 내다봄 + 30% 실수 확률
    'medium': 3,    // 3수 앞을 내다봄
    'hard': 4       // 4수 앞을 내다봄
};

// 초급 난이도 실수 로직
if (difficulty === 'easy' && Math.random() < 0.3) {
    // 상위 5개 중 랜덤 선택
    const randomMove = possibleMoves[Math.floor(Math.random() * 5)];
    return randomMove;
}
```

**복잡도 분석**:
- 분기 계수 (b): ~15-20 (근접 탐색으로 축소)
- 깊이 (d): 2~4
- 예상 노드 수: O(b^(d/2)) ≈ 150~8000 노드
- 실행 시간: 0.5~2초

---

### 2. 오목 규칙 검증 알고리즘

#### 승리 조건 확인

```javascript
function checkWin(board, row, col, color) {
    const directions = [
        [0, 1],   // 가로 →
        [1, 0],   // 세로 ↓
        [1, 1],   // 대각선 ↘
        [1, -1]   // 대각선 ↙
    ];

    for (const [dx, dy] of directions) {
        let count = 1;  // 방금 놓은 돌

        // 양방향으로 탐색
        for (let direction of [-1, 1]) {
            let r = row + dx * direction;
            let c = col + dy * direction;

            while (r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (board[r][c] === color) {
                    count++;
                    r += dx * direction;
                    c += dy * direction;
                } else {
                    break;
                }
            }
        }

        if (count >= 5) {
            return true;
        }
    }

    return false;
}
```

**시간 복잡도**: O(1) - 최대 4방향 × 최대 5칸 = 20번 비교

#### 유효한 착수 확인

```javascript
function isValidMove(board, row, col) {
    // 범위 체크
    if (row < 0 || row >= 15 || col < 0 || col >= 15) {
        return false;
    }

    // 빈 자리 체크
    return board[row][col] === null;
}
```

---

## 백엔드 구조

### 디렉토리 구조

```
server/
├── server.js           # 메인 서버 파일
├── db.js              # MySQL 연결 관리
├── gameLogic.js       # 게임 규칙 로직
├── ai.js              # Minimax AI
└── routes/
    ├── auth.js        # 인증 라우트
    ├── game.js        # 게임 관련 라우트
    └── stats.js       # 통계 라우트
```

### 주요 모듈 설명

#### 1. server.js (메인 서버)

```javascript
const express = require('express');
const session = require('express-session');
const socketIO = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIO(server);

// 세션 설정
app.use(session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: { maxAge: 24 * 60 * 60 * 1000 }  // 24시간
}));

// 라우트 등록
app.use('/api/auth', authRoutes);
app.use('/api/game', gameRoutes);
app.use('/api/stats', statsRoutes);

// Socket.IO 이벤트 처리
const waitingPlayers = [];  // 대기열
const activeGames = new Map();  // 진행 중인 게임

io.on('connection', (socket) => {
    // 매칭 요청
    socket.on('find-match', (data) => {
        if (waitingPlayers.length > 0) {
            // 매칭 성공
            const opponent = waitingPlayers.shift();
            createGame(socket, opponent);
        } else {
            // 대기열 추가
            waitingPlayers.push({ id: socket.id, ...data });
        }
    });

    // 착수
    socket.on('make-move', (data) => {
        const game = activeGames.get(data.gameId);
        // 보드 업데이트 후 상대에게 전송
        io.to(data.gameId).emit('move-made', moveData);
    });
});
```

#### 2. db.js (데이터베이스 연결)

```javascript
const mysql = require('mysql2');

const pool = mysql.createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    waitForConnections: true,
    connectionLimit: 10,  // 최대 10개 연결
    queueLimit: 0
});

const promisePool = pool.promise();

module.exports = { pool: promisePool };
```

**연결 풀 사용 이유**:
- 연결 재사용으로 성능 향상
- 동시 접속 관리
- 자동 재연결

#### 3. routes/auth.js (인증)

```javascript
// 회원가입
router.post('/register', async (req, res) => {
    const { username, password } = req.body;

    // 비밀번호 해싱 (bcrypt, salt rounds: 10)
    const hashedPassword = await bcrypt.hash(password, 10);

    // DB 저장
    await pool.query(
        'INSERT INTO users (username, password) VALUES (?, ?)',
        [username, hashedPassword]
    );
});

// 로그인
router.post('/login', async (req, res) => {
    const { username, password } = req.body;

    // 사용자 조회
    const [users] = await pool.query(
        'SELECT * FROM users WHERE username = ?',
        [username]
    );

    // 비밀번호 검증
    const isValid = await bcrypt.compare(password, users[0].password);

    if (isValid) {
        // 세션에 저장
        req.session.userId = users[0].id;
        req.session.username = users[0].username;
    }
});
```

**보안 특징**:
- bcrypt로 단방향 해싱
- SQL Injection 방지 (Prepared Statement)
- 세션 기반 인증 (쿠키에 세션 ID만 저장)

#### 4. routes/game.js (게임 로직)

```javascript
// AI 착수 요청
router.post('/ai-move', requireAuth, (req, res) => {
    const { board, aiColor, difficulty } = req.body;

    // AI 착수 계산
    const move = findBestMove(board, aiColor, difficulty);

    res.json({ move });
});

// 게임 저장
router.post('/save', requireAuth, async (req, res) => {
    const { gameName, boardState, currentPlayer, gameMode } = req.body;

    await pool.query(
        `INSERT INTO saved_games
        (user_id, game_name, board_state, current_player, game_mode)
        VALUES (?, ?, ?, ?, ?)`,
        [req.session.userId, gameName, JSON.stringify(boardState),
         currentPlayer, gameMode]
    );
});

// 게임 결과 기록
router.post('/record', requireAuth, async (req, res) => {
    const { gameMode, result, totalMoves } = req.body;

    // game_records 테이블에 저장
    await pool.query(
        `INSERT INTO game_records
        (player1_id, game_mode, result, total_moves)
        VALUES (?, ?, ?, ?)`,
        [req.session.userId, gameMode, result, totalMoves]
    );

    // user_statistics 업데이트
    await updateUserStatistics(req.session.userId, gameMode, result);
});
```

---

## 프론트엔드 구조

### 디렉토리 구조

```
public/
├── index.html          # 메인 HTML (SPA)
├── css/
│   └── style.css      # 전체 스타일
└── js/
    ├── api.js         # API 호출 함수
    ├── game.js        # 게임 로직 (Canvas)
    ├── ui.js          # UI 관리
    └── main.js        # 메인 앱 로직
```

### 주요 모듈 설명

#### 1. game.js (Canvas 게임 보드)

```javascript
class OmokuGame {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.boardSize = 15;
        this.cellSize = canvas.width / (this.boardSize + 1);
        this.board = Array(15).fill(null).map(() => Array(15).fill(null));

        this.drawBoard();
        this.setupClickHandler();
    }

    drawBoard() {
        // 배경색
        this.ctx.fillStyle = '#daa520';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 격자선 그리기
        for (let i = 0; i < this.boardSize; i++) {
            // 세로선
            this.ctx.beginPath();
            this.ctx.moveTo(this.cellSize * (i + 1), this.cellSize);
            this.ctx.lineTo(this.cellSize * (i + 1),
                           this.cellSize * this.boardSize);
            this.ctx.stroke();

            // 가로선
            this.ctx.beginPath();
            this.ctx.moveTo(this.cellSize, this.cellSize * (i + 1));
            this.ctx.lineTo(this.cellSize * this.boardSize,
                           this.cellSize * (i + 1));
            this.ctx.stroke();
        }

        // 화점 (star points) 표시
        const starPoints = [[3,3], [3,11], [7,7], [11,3], [11,11]];
        starPoints.forEach(([x, y]) => {
            this.ctx.beginPath();
            this.ctx.arc(
                this.cellSize * (x + 1),
                this.cellSize * (y + 1),
                4, 0, Math.PI * 2
            );
            this.ctx.fill();
        });
    }

    drawStone(row, col, color) {
        const x = this.cellSize * (col + 1);
        const y = this.cellSize * (row + 1);
        const radius = this.cellSize * 0.4;

        // 그림자
        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        this.ctx.shadowBlur = 5;

        // 돌 그리기
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, Math.PI * 2);
        this.ctx.fillStyle = color === 'black' ? '#000' : '#fff';
        this.ctx.fill();

        // 테두리
        this.ctx.strokeStyle = color === 'black' ? '#333' : '#ccc';
        this.ctx.stroke();
    }

    setupClickHandler() {
        this.canvas.addEventListener('click', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 클릭 좌표를 보드 좌표로 변환
            const col = Math.round(x / this.cellSize) - 1;
            const row = Math.round(y / this.cellSize) - 1;

            if (this.isValidMove(row, col)) {
                this.makeMove(row, col);
            }
        });
    }
}
```

**Canvas 좌표계**:
```
(0,0) ────────────► X (600)
  │
  │    ┌─┬─┬─┬─┬─┐
  │    ├─┼─┼─┼─┼─┤
  │    ├─┼─┼─┼─┼─┤
  │    ├─┼─┼─┼─┼─┤
  │    └─┴─┴─┴─┴─┘
  ▼
  Y (600)

cellSize = 600 / (15 + 1) = 37.5px
교점 좌표 = cellSize * (인덱스 + 1)
```

#### 2. main.js (앱 로직)

```javascript
// AI 게임 시작
function startAIGame(difficulty) {
    const canvas = document.getElementById('game-board');
    game = new OmokuGame(canvas);
    game.gameMode = 'ai';
    game.aiDifficulty = difficulty;

    game.onMove = async (row, col, color) => {
        UI.updateTurn(game.currentPlayer);

        // AI 차례
        if (game.currentPlayer === game.aiColor) {
            const result = await API.getAIMove(
                game.board,
                game.aiColor,
                difficulty
            );

            if (result.move) {
                game.makeMove(result.move.row, result.move.col);
            }
        }
    };

    game.onGameEnd = async (winner, totalMoves, gameDuration) => {
        // 게임 결과 기록
        await API.recordGame(
            'ai',
            difficulty,
            winner === game.playerColor ? currentUser.id : null,
            winner ? (winner === game.playerColor ? 'win' : 'lose') : 'draw',
            totalMoves,
            gameDuration
        );

        alert(winner ? `${winner} 승리!` : '무승부!');
    };
}

// 1:1 대전 시작
function startPVPMatchmaking() {
    socket = io();

    socket.on('match-found', (data) => {
        startPVPGame(data.color);
    });

    socket.emit('find-match', {
        userId: currentUser.id,
        username: currentUser.username
    });
}
```

#### 3. api.js (API 호출)

```javascript
const API = {
    async login(username, password) {
        const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        return await response.json();
    },

    async getAIMove(board, aiColor, difficulty) {
        const response = await fetch('/api/game/ai-move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ board, aiColor, difficulty })
        });
        return await response.json();
    },

    async saveGame(gameName, boardState, currentPlayer,
                   gameMode, aiDifficulty, moveHistory) {
        const response = await fetch('/api/game/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                gameName, boardState, currentPlayer,
                gameMode, aiDifficulty, moveHistory
            })
        });
        return await response.json();
    }
};
```

---

## API 명세

### 인증 API

#### POST /api/auth/register
회원가입

**Request**:
```json
{
  "username": "user123",
  "password": "password123",
  "email": "user@example.com"
}
```

**Response**:
```json
{
  "success": true,
  "message": "회원가입이 완료되었습니다.",
  "userId": 1
}
```

#### POST /api/auth/login
로그인

**Request**:
```json
{
  "username": "user123",
  "password": "password123"
}
```

**Response**:
```json
{
  "success": true,
  "message": "로그인 성공",
  "user": {
    "id": 1,
    "username": "user123",
    "email": "user@example.com"
  }
}
```

**세션 쿠키 설정됨**

#### POST /api/auth/logout
로그아웃

**Response**:
```json
{
  "success": true,
  "message": "로그아웃 성공"
}
```

#### GET /api/auth/me
현재 사용자 정보

**Response**:
```json
{
  "user": {
    "id": 1,
    "username": "user123",
    "email": "user@example.com",
    "created_at": "2024-01-01T00:00:00.000Z"
  }
}
```

### 게임 API

#### POST /api/game/ai-move
AI 착수 계산

**Request**:
```json
{
  "board": [[null, "black", ...], ...],
  "aiColor": "white",
  "difficulty": "medium"
}
```

**Response**:
```json
{
  "move": {
    "row": 7,
    "col": 8
  }
}
```

#### POST /api/game/save
게임 저장

**Request**:
```json
{
  "gameName": "내 게임 1",
  "boardState": [[null, "black", ...], ...],
  "currentPlayer": "white",
  "gameMode": "ai",
  "aiDifficulty": "medium",
  "moveHistory": [
    {"row": 7, "col": 7, "color": "black"},
    {"row": 7, "col": 8, "color": "white"}
  ]
}
```

**Response**:
```json
{
  "success": true,
  "message": "게임이 저장되었습니다.",
  "gameId": 5
}
```

#### GET /api/game/saved-games
저장된 게임 목록

**Response**:
```json
{
  "games": [
    {
      "id": 1,
      "game_name": "내 게임 1",
      "game_mode": "ai",
      "ai_difficulty": "medium",
      "current_player": "white",
      "created_at": "2024-01-01T00:00:00.000Z",
      "updated_at": "2024-01-01T01:00:00.000Z"
    }
  ]
}
```

#### GET /api/game/load/:gameId
게임 불러오기

**Response**:
```json
{
  "game": {
    "id": 1,
    "gameName": "내 게임 1",
    "boardState": [[null, "black", ...], ...],
    "currentPlayer": "white",
    "gameMode": "ai",
    "aiDifficulty": "medium",
    "moveHistory": [...]
  }
}
```

#### DELETE /api/game/delete/:gameId
게임 삭제

**Response**:
```json
{
  "success": true,
  "message": "게임이 삭제되었습니다."
}
```

#### POST /api/game/record
게임 결과 기록

**Request**:
```json
{
  "gameMode": "ai",
  "aiDifficulty": "hard",
  "winnerId": 1,
  "result": "win",
  "totalMoves": 42,
  "gameDuration": 180,
  "player2Id": null
}
```

**Response**:
```json
{
  "success": true,
  "message": "게임 결과가 기록되었습니다."
}
```

### 통계 API

#### GET /api/stats/user
사용자 통계

**Response**:
```json
{
  "statistics": {
    "total_games": 50,
    "wins": 30,
    "losses": 15,
    "draws": 5,
    "ai_easy_wins": 10,
    "ai_medium_wins": 8,
    "ai_hard_wins": 2,
    "pvp_wins": 10,
    "win_rate": "60.00"
  }
}
```

#### GET /api/stats/recent-games?limit=10
최근 게임 기록

**Response**:
```json
{
  "games": [
    {
      "id": 1,
      "game_mode": "ai",
      "ai_difficulty": "hard",
      "result": "win",
      "total_moves": 42,
      "played_at": "2024-01-01T00:00:00.000Z",
      "player1_name": "user123",
      "player2_name": null
    }
  ]
}
```

#### GET /api/stats/leaderboard?mode=overall&limit=10
리더보드

**Query Parameters**:
- mode: "overall" | "pvp" | "ai"
- limit: 숫자 (기본값: 10)

**Response**:
```json
{
  "leaderboard": [
    {
      "user_id": 1,
      "username": "player1",
      "total_games": 100,
      "wins": 70,
      "losses": 25,
      "draws": 5,
      "win_rate": "70.00"
    }
  ]
}
```

---

## 실시간 통신 (Socket.IO)

### 이벤트 명세

#### Client → Server

##### find-match
1:1 대전 매칭 요청

**Payload**:
```javascript
{
  userId: 1,
  username: "player1"
}
```

##### cancel-match
매칭 취소

##### make-move
착수

**Payload**:
```javascript
{
  gameId: "game-1234567890",
  row: 7,
  col: 8
}
```

##### game-over
게임 종료

**Payload**:
```javascript
{
  gameId: "game-1234567890",
  winner: "black"
}
```

#### Server → Client

##### waiting
매칭 대기 중

##### match-found
매칭 성공

**Payload**:
```javascript
{
  gameId: "game-1234567890",
  opponent: "player2",
  color: "black"  // or "white"
}
```

##### move-made
상대방 착수 알림

**Payload**:
```javascript
{
  row: 7,
  col: 8,
  color: "white",
  nextPlayer: "black"
}
```

##### game-ended
게임 종료 알림

**Payload**:
```javascript
{
  winner: "black"
}
```

##### opponent-disconnected
상대방 연결 끊김

### 매칭 알고리즘

```javascript
// 대기열
const waitingPlayers = [];

// 진행 중인 게임 (Map)
const activeGames = new Map();

// 매칭 로직
socket.on('find-match', (data) => {
    if (waitingPlayers.length > 0) {
        // 대기 중인 플레이어가 있음
        const opponent = waitingPlayers.shift();  // FIFO

        const gameId = `game-${Date.now()}`;
        const game = {
            id: gameId,
            player1: opponent,
            player2: { id: socket.id, ...data },
            board: createEmptyBoard(),
            currentPlayer: 'black',
            moveHistory: []
        };

        activeGames.set(gameId, game);

        // 양쪽에 알림
        io.to(opponent.id).emit('match-found', {
            gameId,
            opponent: data.username,
            color: 'black'
        });

        io.to(socket.id).emit('match-found', {
            gameId,
            opponent: opponent.username,
            color: 'white'
        });

        // 게임 룸에 추가
        socket.join(gameId);
        io.sockets.sockets.get(opponent.id)?.join(gameId);
    } else {
        // 대기열에 추가
        waitingPlayers.push({
            id: socket.id,
            ...data
        });

        socket.emit('waiting');
    }
});
```

**매칭 순서**:
1. player1이 "1:1 대전" 클릭 → waitingPlayers에 추가
2. player2가 "1:1 대전" 클릭 → player1과 매칭
3. 게임 룸 생성 및 양쪽에 알림
4. player1은 흑돌, player2는 백돌

---

## 성능 최적화

### 1. 데이터베이스 최적화

#### 인덱스
```sql
-- users 테이블
CREATE INDEX idx_username ON users(username);

-- saved_games 테이블
CREATE INDEX idx_user_id ON saved_games(user_id);

-- game_records 테이블
CREATE INDEX idx_player1 ON game_records(player1_id);
CREATE INDEX idx_player2 ON game_records(player2_id);
```

#### 통계 캐싱
`user_statistics` 테이블을 사용하여 집계 쿼리 회피

**Before** (매번 집계):
```sql
SELECT
    COUNT(*) as total_games,
    SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END) as wins
FROM game_records
WHERE player1_id = ?;
```

**After** (캐시 조회):
```sql
SELECT total_games, wins FROM user_statistics WHERE user_id = ?;
```

### 2. AI 최적화

#### 근접 영역 우선 탐색
전체 225칸(15x15) 대신 이미 놓인 돌 주변 2칸 이내만 탐색

```javascript
function getPossibleMoves(board, maxMoves = 20) {
    const moves = [];
    const checked = new Set();

    // 이미 놓인 돌 찾기
    for (let i = 0; i < 15; i++) {
        for (let j = 0; j < 15; j++) {
            if (board[i][j] !== null) {
                // 주변 2칸 탐색
                for (let di = -2; di <= 2; di++) {
                    for (let dj = -2; dj <= 2; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        const key = `${ni},${nj}`;

                        if (!checked.has(key) && isValidMove(board, ni, nj)) {
                            checked.add(key);
                            const score = evaluatePosition(board, ni, nj);
                            moves.push({ row: ni, col: nj, score });
                        }
                    }
                }
            }
        }
    }

    // 점수 순 정렬 후 상위 N개만 반환
    moves.sort((a, b) => b.score - a.score);
    return moves.slice(0, maxMoves);
}
```

**효과**:
- 탐색 공간: 225칸 → 15~30칸
- 속도 향상: 약 7~15배

#### 즉시 승리/패배 확인
Minimax 탐색 전에 즉시 이기거나 막아야 하는 수 확인

```javascript
function findBestMove(board, aiColor, difficulty) {
    const opponent = aiColor === 'black' ? 'white' : 'black';
    const possibleMoves = getPossibleMoves(board, 20);

    // 상대의 4목 막기
    for (const move of possibleMoves) {
        board[move.row][move.col] = opponent;
        if (checkWin(board, move.row, move.col, opponent)) {
            board[move.row][move.col] = null;
            return move;  // 즉시 반환
        }
        board[move.row][move.col] = null;
    }

    // AI가 즉시 이길 수 있는 경우
    for (const move of possibleMoves) {
        board[move.row][move.col] = aiColor;
        if (checkWin(board, move.row, move.col, aiColor)) {
            board[move.row][move.col] = null;
            return move;  // 즉시 반환
        }
        board[move.row][move.col] = null;
    }

    // Minimax 실행
    return minimax(board, depth, -Infinity, Infinity, true, aiColor);
}
```

### 3. 프론트엔드 최적화

#### Canvas 부분 렌더링
전체 보드 대신 변경된 부분만 다시 그리기 (추가 구현 가능)

#### 디바운싱
연속된 클릭 방지

```javascript
let isProcessing = false;

canvas.addEventListener('click', async (e) => {
    if (isProcessing) return;
    isProcessing = true;

    // 착수 처리
    await makeMove(row, col);

    isProcessing = false;
});
```

---

## 보안

### 1. 비밀번호 보안

```javascript
// bcrypt 해싱 (salt rounds: 10)
const hashedPassword = await bcrypt.hash(password, 10);

// 검증
const isValid = await bcrypt.compare(inputPassword, hashedPassword);
```

**특징**:
- 단방향 해싱 (복호화 불가능)
- Salt 자동 생성
- 같은 비밀번호도 다른 해시값

### 2. SQL Injection 방지

```javascript
// ❌ 취약한 코드
const query = `SELECT * FROM users WHERE username = '${username}'`;

// ✅ 안전한 코드 (Prepared Statement)
const [users] = await pool.query(
    'SELECT * FROM users WHERE username = ?',
    [username]
);
```

### 3. XSS 방지

프론트엔드에서 사용자 입력을 DOM에 직접 삽입하지 않음

```javascript
// ❌ 취약한 코드
element.innerHTML = userInput;

// ✅ 안전한 코드
element.textContent = userInput;
```

### 4. 세션 보안

```javascript
app.use(session({
    secret: process.env.SESSION_SECRET,  // 환경 변수로 관리
    resave: false,
    saveUninitialized: false,
    cookie: {
        httpOnly: true,   // JavaScript 접근 차단
        secure: false,    // HTTPS에서는 true
        maxAge: 24 * 60 * 60 * 1000
    }
}));
```

### 5. 환경 변수

민감한 정보는 `.env` 파일로 관리

```env
DB_PASSWORD=your_password
SESSION_SECRET=random_secret_key
```

`.gitignore`에 추가:
```
.env
*.db
node_modules/
```

---

## 테스트 시나리오

### 1. 단위 테스트

#### 게임 로직 테스트
```javascript
// 승리 조건 테스트
const board = createEmptyBoard();
board[7][7] = 'black';
board[7][8] = 'black';
board[7][9] = 'black';
board[7][10] = 'black';
board[7][11] = 'black';

assert(checkWin(board, 7, 11, 'black') === true);
```

#### AI 테스트
```javascript
// AI가 막아야 하는 상황
const board = createEmptyBoard();
board[7][7] = 'black';
board[7][8] = 'black';
board[7][9] = 'black';
board[7][10] = 'black';
// board[7][11]을 막아야 함

const move = findBestMove(board, 'white', 'easy');
assert(move.row === 7 && (move.col === 6 || move.col === 11));
```

### 2. 통합 테스트

#### API 테스트
```javascript
// 회원가입 → 로그인 → AI 대전 → 저장
const user = await API.register('testuser', 'password');
const login = await API.login('testuser', 'password');
const aiMove = await API.getAIMove(board, 'white', 'medium');
const save = await API.saveGame('테스트 게임', board, ...);
```

### 3. E2E 테스트

1. 회원가입 및 로그인
2. AI 대전 (초급) 플레이
3. 게임 저장
4. 로그아웃 후 재로그인
5. 게임 불러오기
6. 게임 재개 및 종료
7. 전적 확인

---

## 배포 가이드

### 1. 로컬 환경

```bash
# 1. 의존성 설치
npm install

# 2. MySQL 설정
mysql -u root -p omoku_game < database.sql

# 3. .env 파일 생성
cp .env.example .env
# .env 파일 수정

# 4. 서버 실행
npm start
```

### 2. 프로덕션 배포

#### PM2 사용 (프로세스 관리)

```bash
# PM2 설치
npm install -g pm2

# 서버 시작
pm2 start server.js --name omoku-game

# 자동 재시작 설정
pm2 startup
pm2 save

# 로그 확인
pm2 logs omoku-game
```

#### Nginx 리버스 프록시

```nginx
server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Socket.IO
    location /socket.io/ {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

#### HTTPS 설정 (Let's Encrypt)

```bash
# Certbot 설치
sudo apt install certbot python3-certbot-nginx

# SSL 인증서 발급
sudo certbot --nginx -d your-domain.com
```

---

## 확장 가능성

### 1. 추가 기능 아이디어

- **채팅 시스템**: Socket.IO로 실시간 채팅
- **관전 모드**: 다른 사람의 게임 관전
- **토너먼트**: 대회 시스템
- **복기 기능**: 과거 게임 다시보기
- **AI 학습**: 강화학습으로 AI 강화
- **모바일 앱**: React Native로 앱 개발

### 2. 성능 개선

- **Redis 캐싱**: 세션 및 통계 캐싱
- **CDN**: 정적 파일 배포
- **데이터베이스 샤딩**: 사용자 증가 시
- **로드 밸런싱**: 여러 서버로 분산

### 3. 모니터링

```javascript
// Winston 로깅
const winston = require('winston');

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.json(),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
    ]
});

// 사용
logger.info('Game started', { userId, gameMode });
logger.error('AI move failed', { error });
```

---

## 결론

이 프로젝트는 다음 기술들을 종합적으로 활용합니다:

- **알고리즘**: Minimax, Alpha-Beta Pruning
- **백엔드**: Node.js, Express, MySQL
- **실시간 통신**: Socket.IO
- **프론트엔드**: Canvas API, Vanilla JavaScript
- **보안**: bcrypt, 세션 관리, SQL Injection 방지

전체 아키텍처는 확장 가능하고 유지보수가 쉽도록 모듈화되어 있으며, 성능 최적화와 보안을 고려하여 설계되었습니다.
